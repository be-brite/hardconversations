// Code generated by hardc. DO NOT EDIT.

package moderatorai

import (
	"context"

	"github.com/be-brite/hardconversations/chat"
	
)


const instruction = `Given the rules of a community and a piece of text, you are able to determine how likely it is that the text breaks the rules.
`

type Client struct {
	*chat.Client
}

func NewClient(openAIKey string) *Client {
	c := &Client{
		Client: chat.NewClient(openAIKey, instruction),
	}

	return c
}

type Thread struct {
	*chat.Thread
}

func (c *Client) NewThread() *Thread {
	return &Thread{
		Thread: c.Client.NewThread(),
	}
}



// TODO: handle different input and output types, arrays, structs, etc
func (t *Thread) LikelihoodToBreakRules(ctx context.Context, input string) (result int, md chat.Metadata, err error) {
	const prompt = `How likely is it that the text breaks the rules? (Answer must be an integer between 0 and 100)` // TODO initialize text embedding

	parseInstruction, err := chat.ParseInstruction(result)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	fullPrompt := parseInstruction + prompt
	inputStr, err := chat.ConvertInput(input)
	if err != nil {
		return result, chat.Metadata{}, err
	}
	fullPrompt += "\n" + inputStr
	

	output, md, err := t.Thread.ExecutePrompt(ctx, fullPrompt)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	err = chat.Parse(output, &result)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	return result, md, nil
}



// TODO: handle different input and output types, arrays, structs, etc
func (t *Thread) WhichRulesDoesItBreak(ctx context.Context) (result []int, md chat.Metadata, err error) {
	const prompt = `Which rule numbers does the text break? (Answer must be a comma-separated list of integers)` // TODO initialize text embedding

	parseInstruction, err := chat.ParseInstruction(result)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	fullPrompt := parseInstruction + prompt

	output, md, err := t.Thread.ExecutePrompt(ctx, fullPrompt)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	err = chat.Parse(output, &result)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	return result, md, nil
}



// TODO: handle different input and output types, arrays, structs, etc
func (t *Thread) WhyDoesItBreakTheRules(ctx context.Context) (result string, md chat.Metadata, err error) {
	const prompt = `Why does it break the rules?` // TODO initialize text embedding

	parseInstruction, err := chat.ParseInstruction(result)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	fullPrompt := parseInstruction + prompt

	output, md, err := t.Thread.ExecutePrompt(ctx, fullPrompt)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	err = chat.Parse(output, &result)
	if err != nil {
		return result, chat.Metadata{}, err
	}

	return result, md, nil
}

